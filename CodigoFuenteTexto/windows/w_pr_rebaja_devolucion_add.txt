forward
global type w_pr_rebaja_devolucion_add from w_master_list
end type
end forward

global type w_pr_rebaja_devolucion_add from w_master_list
integer width = 3835
integer height = 2300
string title = "Rebajas o Devoluciones"
boolean minbox = false
boolean maxbox = false
boolean resizable = false
windowtype windowtype = response!
end type
global w_pr_rebaja_devolucion_add w_pr_rebaja_devolucion_add

forward prototypes
public subroutine wf_cerrar_periodo ()
public subroutine wf_position ()
public function integer wf_crear_nuevo (string as_periodo, string as_tipoplanilla, string as_tipoproceso, long al_empleado)
public function integer wf_cargar_existente (long al_idrebajadevolucion)
public function integer wf_cargar_conceptos_planilla (string as_periodo, string as_tipoplanilla, string as_tipoproceso, long al_empleado)
public function long wf_obtener_dias_trabajados (string as_periodo, string as_tipoplanilla, string as_tipoproceso, long al_empleado)
public function integer wf_validar_periodo_estado (string as_periodo)
public function integer wf_validar_rebaja_existente (string as_periodo, string as_tipoplanilla, string as_tipoproceso, long al_empleado)
public function integer wf_recalcular_conceptos (long al_diasnuevos, string as_conjunto)
public function boolean wf_concepto_en_grupo (string as_concepto, string as_conjunto)
public subroutine wf_calcular_montoajuste ()
public function integer wf_grabar ()
end prototypes

public subroutine wf_cerrar_periodo ();
/*==================================================================
Función: wf_cerrar_periodo
Propósito: Cerrar un período de rebajas y devoluciones
==================================================================*/
long ll_row
integer li_result
string ls_periodo, ls_estado
datetime ldt_ahora

ll_row = dw_2.GetRow()

IF ll_row <= 0 THEN
    MessageBox("Advertencia", "Debe seleccionar un período", Exclamation!)
    RETURN
END IF

ls_periodo = dw_2.GetItemString(ll_row, "periodo")
ls_estado = dw_2.GetItemString(ll_row, "estado")

IF ls_estado <> "PROCESO" THEN
    MessageBox("Advertencia", "El período " + ls_periodo + " ya está cerrado", StopSign!)
    RETURN
END IF

IF MessageBox("Confirmación", &
    "¿Está seguro de cerrar el período " + ls_periodo + "?~r~n~r~n" + &
    "Esta acción no se puede deshacer.", &
    Question!, YesNo!) <> 1 THEN
    RETURN
END IF

ldt_ahora = DateTime(Today(), Now())

// Actualizar estado y fecha de cierre
dw_2.SetItem(ll_row, "estado", "CERRADO")
dw_2.SetItem(ll_row, "fecha_cierre", ldt_ahora)

// Guardar en base de datos
li_result = dw_2.Update()

IF li_result = 1 THEN
    COMMIT;
    MessageBox("Información", "Período " + ls_periodo + " cerrado exitosamente", Information!)
    dw_2.Retrieve()
ELSE
    ROLLBACK;
    MessageBox("Error", "No se pudo cerrar el período:~r~n" + SQLCA.SQLErrText, StopSign!)
END IF

end subroutine

public subroutine wf_position ();
/*==================================================================
Función: wf_position
Propósito: Buscar un período específico en el DataWindow
==================================================================*/
string ls_buscar
long ll_row

// Obtener el texto del campo de búsqueda
ls_buscar = Trim(Upper(sle_position.Text))

IF Len(ls_buscar) = 0 THEN
    MessageBox("Información", "Ingrese un período para buscar~r~nFormato: YYYY-MM (ej: 2024-08)", Information!)
    sle_position.SetFocus()
    RETURN
END IF

// Buscar el período en el DataWindow
ll_row = dw_2.Find("periodo = '" + ls_buscar + "'", 1, dw_2.RowCount())

IF ll_row > 0 THEN
    // Encontrado: posicionarse y seleccionar la fila
    dw_2.ScrollToRow(ll_row)
    dw_2.SelectRow(0, FALSE)
    dw_2.SelectRow(ll_row, TRUE)
    dw_2.SetRow(ll_row)
    dw_2.SetColumn("periodo")
    dw_2.SetFocus()

    // Actualizar variable de posición (por compatibilidad con w_master_list)
    iv_position = ls_buscar
ELSE
    // No encontrado
    MessageBox("Búsqueda", "No se encontró el período: " + ls_buscar, Information!)
    sle_position.SetFocus()
    sle_position.SelectText(1, Len(sle_position.Text))
END IF

end subroutine

public function integer wf_crear_nuevo (string as_periodo, string as_tipoplanilla, string as_tipoproceso, long al_empleado);/*==================================================================
Función: wf_crear_nuevo
Propósito: Crear nuevo registro de rebaja/devolución
Parámetros:
   - as_periodo: Periodo de la planilla
   - as_tipoplanilla: Tipo de planilla
   - as_tipoproceso: Tipo de proceso
   - al_empleado: Código del empleado
Retorna: 1=Éxito, -1=Error
==================================================================*/

long ll_row
string ls_tiporegistro
integer li_resultado

// 1. Validar que el período esté en estado válido y determinar tipo
li_resultado = wf_validar_periodo_estado(as_periodo)

IF li_resultado < 0 THEN
	RETURN -1
END IF

// 2. Crear nueva fila en cabecera
ll_row = dw_2.InsertRow(0)

IF ll_row <= 0 THEN
	MessageBox("Error", "No se pudo crear la fila en el DataWindow de cabecera", StopSign!)
	RETURN -1
END IF

// 3. Asignar valores iniciales a la cabecera
dw_2.SetItem(ll_row, "periodo", as_periodo)
dw_2.SetItem(ll_row, "tipoplanilla", as_tipoplanilla)
dw_2.SetItem(ll_row, "tipoproceso", as_tipoproceso)
dw_2.SetItem(ll_row, "empleado", al_empleado)
dw_2.SetItem(ll_row, "estado", "T")
dw_2.SetItem(ll_row, "totalmonto", 0)
dw_2.SetItem(ll_row, "fechacreacion", DateTime(Today(), Now()))
dw_2.SetItem(ll_row, "usuariocreacion", str_global.gv_userid)

// 4. Cargar conceptos de la planilla en el detalle
li_resultado = wf_cargar_conceptos_planilla(as_periodo, as_tipoplanilla, as_tipoproceso, al_empleado)

IF li_resultado < 0 THEN
	dw_2.DeleteRow(ll_row)
	RETURN -1
END IF

// 5. Cambiar título de la ventana
This.Title = "Nueva Rebaja/Devolución - Empleado: " + String(al_empleado) + " - Periodo: " + as_periodo

RETURN 1

end function

public function integer wf_cargar_existente (long al_idrebajadevolucion);/*==================================================================
Función: wf_cargar_existente
Propósito: Cargar registro existente para edición
Parámetros:
   - al_idrebajadevolucion: ID del registro a cargar
Retorna: 1=Éxito, -1=Error
==================================================================*/

integer li_rowcount
long ll_empleado
string ls_periodo, ls_estado

// 1. Retrieve cabecera
li_rowcount = dw_2.Retrieve(al_idrebajadevolucion)

IF li_rowcount <= 0 THEN
	MessageBox("Error", "No se encontró el registro con ID: " + String(al_idrebajadevolucion), StopSign!)
	RETURN -1
END IF

// 2. Obtener datos para validaciones
ls_estado = dw_2.GetItemString(1, "estado")
ll_empleado = dw_2.GetItemNumber(1, "empleado")
ls_periodo = dw_2.GetItemString(1, "periodo")

// 3. Validar que el registro esté en estado editable
IF ls_estado <> "T" AND ls_estado <> "C" THEN
	MessageBox("Advertencia", &
		"Este registro no puede ser modificado.~r~n" + &
		"Estado actual: " + ls_estado, StopSign!)
	RETURN -1
END IF

// 4. Retrieve detalle
li_rowcount = dw_3.Retrieve(al_idrebajadevolucion)

IF li_rowcount < 0 THEN
	MessageBox("Error", "Error al cargar el detalle de conceptos", StopSign!)
	RETURN -1
END IF

// 5. Cambiar título de la ventana
This.Title = "Editar Rebaja/Devolución - ID: " + String(al_idrebajadevolucion) + &
	" - Empleado: " + String(ll_empleado) + " - Periodo: " + ls_periodo

RETURN 1

end function

public function integer wf_cargar_conceptos_planilla (string as_periodo, string as_tipoplanilla, string as_tipoproceso, long al_empleado);/*==================================================================
Función: wf_cargar_conceptos_planilla
Propósito: Cargar todos los conceptos de la planilla del empleado en el detalle
Parámetros:
   - as_periodo: Periodo de la planilla
   - as_tipoplanilla: Tipo de planilla
   - as_tipoproceso: Tipo de proceso
   - al_empleado: Código del empleado
Retorna: 1=Éxito, -1=Error
Nota: Carga TODOS los conceptos, MontoFinal = MontoOriginal, MontoAjuste = 0
==================================================================*/

DataStore lds_conceptos
integer li_rowcount, li_i
long ll_newrow, ll_diastrabajados
string ls_concepto, ls_descripcion
decimal{2} ldc_monto, ldc_cantidad

// 1. Crear DataStore para consultar conceptos
lds_conceptos = CREATE DataStore
lds_conceptos.DataObject = "d_consulta_conceptos_planilla"
lds_conceptos.SetTransObject(SQLCA)

// 2. Retrieve conceptos de la planilla
li_rowcount = lds_conceptos.Retrieve(as_periodo, as_tipoplanilla, as_tipoproceso, al_empleado)

IF li_rowcount < 0 THEN
	MessageBox("Error", "Error al consultar los conceptos de la planilla", StopSign!)
	DESTROY lds_conceptos
	RETURN -1
END IF

IF li_rowcount = 0 THEN
	MessageBox("Advertencia", &
		"No se encontraron conceptos para el empleado " + String(al_empleado) + &
		"~r~nen el período " + as_periodo, Exclamation!)
	DESTROY lds_conceptos
	RETURN -1
END IF

// 3. Obtener días trabajados del empleado (para guardarlo en cabecera)
ll_diastrabajados = wf_obtener_dias_trabajados(as_periodo, as_tipoplanilla, as_tipoproceso, al_empleado)

IF ll_diastrabajados > 0 THEN
	dw_2.SetItem(1, "diastrabajadosoriginal", ll_diastrabajados)
END IF

// 4. Limpiar detalle (por si acaso)
dw_3.Reset()

// 5. Recorrer todos los conceptos y agregarlos al detalle
FOR li_i = 1 TO li_rowcount
	ls_concepto = lds_conceptos.GetItemString(li_i, "concepto")
	ls_descripcion = lds_conceptos.GetItemString(li_i, "descripcion")
	ldc_monto = lds_conceptos.GetItemDecimal(li_i, "monto")

	// Insertar fila en detalle
	ll_newrow = dw_3.InsertRow(0)

	IF ll_newrow <= 0 THEN
		MessageBox("Error", "No se pudo insertar fila en el detalle", StopSign!)
		DESTROY lds_conceptos
		RETURN -1
	END IF

	// Asignar valores
	dw_3.SetItem(ll_newrow, "concepto", ls_concepto)
	dw_3.SetItem(ll_newrow, "descripcion", ls_descripcion)
	dw_3.SetItem(ll_newrow, "montooriginal", ldc_monto)
	dw_3.SetItem(ll_newrow, "montofinal", 0)
	dw_3.SetItem(ll_newrow, "montoajuste", ldc_monto * -1)
NEXT

// 6. Destruir DataStore
DESTROY lds_conceptos

RETURN 1

end function

public function long wf_obtener_dias_trabajados (string as_periodo, string as_tipoplanilla, string as_tipoproceso, long al_empleado);/*==================================================================
Función: wf_obtener_dias_trabajados
Propósito: Obtener los días trabajados del empleado en la planilla
Parámetros:
   - as_periodo: Periodo de la planilla
   - as_tipoplanilla: Tipo de planilla
   - as_tipoproceso: Tipo de proceso
   - al_empleado: Código del empleado
Retorna: Días trabajados (0 si no se encuentra o hay error)
==================================================================*/

DataStore lds_dias
integer li_rowcount
long ll_dias

// 1. Crear DataStore
lds_dias = CREATE DataStore
lds_dias.DataObject = "d_consulta_dias_trabajados"
lds_dias.SetTransObject(SQLCA)

// 2. Retrieve
li_rowcount = lds_dias.Retrieve(as_periodo, as_tipoplanilla, as_tipoproceso, al_empleado)

IF li_rowcount > 0 THEN
	ll_dias = lds_dias.GetItemNumber(1, "diastrabajados")

	IF IsNull(ll_dias) THEN
		ll_dias = 0
	END IF
ELSE
	ll_dias = 0
END IF

// 3. Destruir DataStore
DESTROY lds_dias

RETURN ll_dias

end function

public function integer wf_validar_periodo_estado (string as_periodo);/*==================================================================
Función: wf_validar_periodo_estado
Propósito: Validar que el período exista y determinar el tipo de registro
Retorna: 1=REBAJA (período en PROCESO), 2=DEVOLUCIÓN (período CERRADO), -1=Error
Efecto secundario: Asigna TipoRegistro en dw_2 (fila 1)
==================================================================*/

DataStore lds_periodo
integer li_rowcount
string ls_estado, ls_tiporegistro, ls_periodo_formato
string ls_anio, ls_mes

// 0. Convertir formato de período YYYYMMDD a YYYY-MM
IF Len(Trim(as_periodo)) = 8 THEN
	ls_anio = Mid(as_periodo, 1, 4)
	ls_mes = Mid(as_periodo, 5, 2)
	ls_periodo_formato = ls_anio + "-" + ls_mes
ELSEIF Len(Trim(as_periodo)) = 7 AND Pos(as_periodo, "-") > 0 THEN
	ls_periodo_formato = as_periodo
ELSE
	MessageBox("Error", &
		"Formato de período inválido: " + as_periodo + "~r~n" + &
		"Se esperaba formato YYYYMMDD (ej: 20250909) o YYYY-MM (ej: 2025-09)", &
		StopSign!)
	RETURN -1
END IF

// 1. Crear DataStore
lds_periodo = CREATE DataStore
lds_periodo.DataObject = "d_verificar_periodo_estado"
lds_periodo.SetTransObject(SQLCA)

// 2. Retrieve con formato convertido
li_rowcount = lds_periodo.Retrieve(ls_periodo_formato)

IF li_rowcount < 0 THEN
	MessageBox("Error", "Error al consultar el estado del período", StopSign!)
	DESTROY lds_periodo
	RETURN -1
END IF

IF li_rowcount = 0 THEN
	MessageBox("Error", &
		"El período " + ls_periodo_formato + " no existe en la tabla PR_PlanillaPeriodo_Rebaja_Devolucion", &
		StopSign!)
	DESTROY lds_periodo
	RETURN -1
END IF

// 3. Obtener estado
ls_estado = Upper(Trim(lds_periodo.GetItemString(1, "estado")))

// 4. Destruir DataStore
DESTROY lds_periodo

// 5. Determinar tipo según estado
CHOOSE CASE ls_estado
	CASE "PROCESO"
		ls_tiporegistro = "R"

	CASE "CERRADO"
		ls_tiporegistro = "D"

	CASE ELSE
		MessageBox("Error", &
			"El estado del período es '" + ls_estado + "'.~r~n" + &
			"Solo se permiten estados 'PROCESO' o 'CERRADO'.", &
			StopSign!)
		RETURN -1
END CHOOSE

// 6. Asignar TipoRegistro en cabecera
dw_2.SetItem(1, "tiporegistro", ls_tiporegistro)

// 7. Retornar código
IF ls_tiporegistro = "R" THEN
	RETURN 1
ELSE
	RETURN 2
END IF

end function

public function integer wf_validar_rebaja_existente (string as_periodo, string as_tipoplanilla, string as_tipoproceso, long al_empleado);/*==================================================================
Función: wf_validar_rebaja_existente
Propósito: Verificar que no exista una rebaja/devolución en trámite
Retorna: 1=No existe (OK), -1=Ya existe en trámite
==================================================================*/

DataStore lds_existente
integer li_rowcount
long ll_id
string ls_tipo, ls_estado, ls_mensaje_tipo

// 1. Crear DataStore
lds_existente = CREATE DataStore
lds_existente.DataObject = "d_verificar_rebaja_existente"
lds_existente.SetTransObject(SQLCA)

// 2. Retrieve
li_rowcount = lds_existente.Retrieve(as_periodo, as_tipoplanilla, as_tipoproceso, al_empleado)

IF li_rowcount < 0 THEN
	MessageBox("Error", "Error al verificar rebajas/devoluciones existentes", StopSign!)
	DESTROY lds_existente
	RETURN -1
END IF

IF li_rowcount > 0 THEN
	ll_id = lds_existente.GetItemNumber(1, "idrebajadevolucion")
	ls_tipo = lds_existente.GetItemString(1, "tiporegistro")
	ls_estado = lds_existente.GetItemString(1, "estado")

	DESTROY lds_existente

	IF ls_tipo = "R" THEN
		ls_mensaje_tipo = "REBAJA"
	ELSE
		ls_mensaje_tipo = "DEVOLUCIÓN"
	END IF

	MessageBox("Advertencia", &
		"Ya existe una " + ls_mensaje_tipo + &
		" en trámite para este empleado:~r~n~r~n" + &
		"ID: " + String(ll_id) + "~r~n" + &
		"Estado: " + ls_estado + "~r~n~r~n" + &
		"Debe consolidar o anular el registro existente antes de crear uno nuevo.", &
		Exclamation!)

	RETURN -1
END IF

// 3. Destruir DataStore
DESTROY lds_existente

RETURN 1

end function

public function boolean wf_concepto_en_grupo (string as_concepto, string as_conjunto);/*==================================================================
Función: wf_concepto_en_grupo
Propósito: Verificar si un concepto pertenece a un conjunto específico
Parámetros:
   - as_concepto: Código del concepto
   - as_conjunto: Código del conjunto (ej: "PRECONESP")
Retorna: TRUE si pertenece, FALSE si no
==================================================================*/

DataStore lds_grupo
integer li_rowcount

// 1. Crear DataStore
lds_grupo = CREATE DataStore
lds_grupo.DataObject = "d_verificar_grupo_conrebdev"
lds_grupo.SetTransObject(SQLCA)

// 2. Retrieve
li_rowcount = lds_grupo.Retrieve(as_conjunto, as_concepto)

// 3. Destruir DataStore
DESTROY lds_grupo

// 4. Retornar resultado
IF li_rowcount > 0 THEN
	RETURN TRUE
ELSE
	RETURN FALSE
END IF

end function

public function integer wf_recalcular_conceptos (long al_diasnuevos, string as_conjunto);/*==================================================================
Función: wf_recalcular_conceptos
Propósito: Recalcular proporcionalmente los conceptos del conjunto especificado
Fórmula: Nuevo Monto = Monto Original × (Días Nuevos / Días Originales)
Parámetros:
   - al_diasnuevos: Nuevos días trabajados
   - as_conjunto: Conjunto de conceptos a recalcular (ej: "PRECONESP")
Retorna: 1=Éxito, -1=Error
==================================================================*/

long ll_rowcount, ll_i, ll_diasoriginales
string ls_concepto
decimal{2} ldc_montooriginal, ldc_montofinal_nuevo
boolean lb_pertenece
integer li_recalculados

// 1. Validaciones
IF IsNull(al_diasnuevos) OR al_diasnuevos <= 0 THEN
	MessageBox("Error", "Los días nuevos deben ser mayor a cero", StopSign!)
	RETURN -1
END IF

IF IsNull(as_conjunto) OR Trim(as_conjunto) = "" THEN
	MessageBox("Error", "Debe especificar el conjunto de conceptos", StopSign!)
	RETURN -1
END IF

// 2. Obtener días originales de la cabecera
ll_diasoriginales = dw_2.GetItemNumber(1, "diastrabajadosoriginal")

IF IsNull(ll_diasoriginales) OR ll_diasoriginales <= 0 THEN
	MessageBox("Error", &
		"No se encontraron los días trabajados originales.~r~n" + &
		"No se puede realizar el recálculo proporcional.", &
		StopSign!)
	RETURN -1
END IF

// 3. Verificar que los días sean diferentes
IF al_diasnuevos = ll_diasoriginales THEN
	MessageBox("Información", &
		"Los días nuevos (" + String(al_diasnuevos) + ") son iguales a los originales.~r~n" + &
		"No es necesario recalcular.", &
		Information!)
	RETURN 1
END IF

// 4. Recorrer detalle y recalcular conceptos del conjunto
ll_rowcount = dw_3.RowCount()
li_recalculados = 0

FOR ll_i = 1 TO ll_rowcount
	ls_concepto = dw_3.GetItemString(ll_i, "concepto")

	lb_pertenece = wf_concepto_en_grupo(ls_concepto, as_conjunto)

	IF lb_pertenece THEN
		ldc_montooriginal = dw_3.GetItemDecimal(ll_i, "montooriginal")

		IF NOT IsNull(ldc_montooriginal) AND ldc_montooriginal <> 0 THEN
			ldc_montofinal_nuevo = ldc_montooriginal * (al_diasnuevos / ll_diasoriginales)
			ldc_montofinal_nuevo = Dec(ldc_montofinal_nuevo)
			dw_3.SetItem(ll_i, "montofinal", ldc_montofinal_nuevo)
			li_recalculados++
		END IF
	END IF
NEXT

// 5. Recalcular MontoAjuste para todas las filas
wf_calcular_montoajuste()

// 6. Mensaje informativo
MessageBox("Información", &
	"Recálculo completado:~r~n~r~n" + &
	"Días originales: " + String(ll_diasoriginales) + "~r~n" + &
	"Días nuevos: " + String(al_diasnuevos) + "~r~n" + &
	"Conceptos recalculados: " + String(li_recalculados) + "~r~n" + &
	"Conjunto: " + as_conjunto, &
	Information!)

RETURN 1

end function

public subroutine wf_calcular_montoajuste ();/*==================================================================
Subroutine: wf_calcular_montoajuste
Propósito: Calcular MontoAjuste para todas las filas del detalle
Fórmula: MontoAjuste = MontoFinal - MontoOriginal
==================================================================*/

long ll_rowcount, ll_i
decimal{2} ldc_montooriginal, ldc_montofinal, ldc_montoajuste

ll_rowcount = dw_3.RowCount()

FOR ll_i = 1 TO ll_rowcount
	ldc_montooriginal = dw_3.GetItemDecimal(ll_i, "montooriginal")
	ldc_montofinal = dw_3.GetItemDecimal(ll_i, "montofinal")

	IF NOT IsNull(ldc_montooriginal) AND NOT IsNull(ldc_montofinal) THEN
		ldc_montoajuste = ldc_montofinal - ldc_montooriginal
	ELSE
		ldc_montoajuste = 0
	END IF

	dw_3.SetItem(ll_i, "montoajuste", ldc_montoajuste)
NEXT

end subroutine

public function integer wf_grabar ();/*==================================================================
Función: wf_grabar
Propósito: Grabar cabecera y detalle de rebaja/devolución
Retorna: 1=Éxito, -1=Error
==================================================================*/

long ll_idrebajadevolucion, ll_rowcount, ll_i
decimal{2} ldc_totalmonto, ldc_montoajuste
string ls_modo
integer li_resultado

// 1. Determinar modo
ls_modo = This.Tag

// 2. Validaciones
IF dw_2.RowCount() = 0 THEN
	MessageBox("Error", "No hay datos en la cabecera para grabar", StopSign!)
	RETURN -1
END IF

IF dw_3.RowCount() = 0 THEN
	MessageBox("Error", "No hay conceptos en el detalle para grabar", StopSign!)
	RETURN -1
END IF

// 3. Calcular total
ldc_totalmonto = 0
ll_rowcount = dw_3.RowCount()

FOR ll_i = 1 TO ll_rowcount
	ldc_montoajuste = dw_3.GetItemDecimal(ll_i, "montoajuste")
	IF NOT IsNull(ldc_montoajuste) THEN
		ldc_totalmonto = ldc_totalmonto + ldc_montoajuste
	END IF
NEXT

// 4. Asignar total
dw_2.SetItem(1, "totalmonto", ldc_totalmonto)
dw_2.SetItem(1, "ultimousuario", str_global.gv_userid)
dw_2.SetItem(1, "ultimafechamodif", DateTime(Today(), Now()))

// 5. Grabar cabecera
li_resultado = dw_2.Update()

IF li_resultado <> 1 THEN
	MessageBox("Error", "No se pudo grabar la cabecera:~r~n~r~n" + SQLCA.SQLErrText, StopSign!)
	ROLLBACK;
	RETURN -1
END IF

// 6. Si es NUEVO, obtener ID
IF ls_modo = "NUEVO" THEN
	ll_idrebajadevolucion = dw_2.GetItemNumber(1, "idrebajadevolucion")

	IF IsNull(ll_idrebajadevolucion) OR ll_idrebajadevolucion <= 0 THEN
		MessageBox("Error", "No se pudo obtener el ID generado", StopSign!)
		ROLLBACK;
		RETURN -1
	END IF

	FOR ll_i = 1 TO ll_rowcount
		dw_3.SetItem(ll_i, "idrebajadevolucion", ll_idrebajadevolucion)
	NEXT
END IF

// 7. Grabar detalle
li_resultado = dw_3.Update()

IF li_resultado <> 1 THEN
	MessageBox("Error", "No se pudo grabar el detalle:~r~n~r~n" + SQLCA.SQLErrText, StopSign!)
	ROLLBACK;
	RETURN -1
END IF

// 8. COMMIT
COMMIT;

MessageBox("Información", &
	"Rebaja/Devolución grabada exitosamente.~r~n~r~n" + &
	"ID: " + String(dw_2.GetItemNumber(1, "idrebajadevolucion")) + "~r~n" + &
	"Total Ajuste: " + String(ldc_totalmonto, "#,##0.00"), &
	Information!)

This.Tag = "EDITAR"

RETURN 1

end function

on w_pr_rebaja_devolucion_add.create
call super::create
end on

on w_pr_rebaja_devolucion_add.destroy
call super::destroy
end on

event open;call super::open
/*==================================================================
Evento: open
Propósito: Inicializar ventana de Rebajas/Devoluciones
Parámetros esperados (str_pass):
   - s[1] = Periodo
   - s[2] = TipoPlanilla
   - s[3] = TipoProceso
   - s[4] = Empleado (string)
   - s[5] = Nombre del Empleado
   - s[6] = DiasTrabajados (string)

Lógica Automática:
   - Busca si existe un registro en trámite (Estado = 'T' o 'C')
   - Si existe: Modo EDITAR (carga el registro existente)
   - Si NO existe: Modo NUEVO (crea registro nuevo)
==================================================================*/

str_pass lstr_param
string ls_periodo, ls_tipoplanilla, ls_tipoproceso
long ll_empleado, ll_idrebajadevolucion
integer li_resultado
DataStore lds_verificar
integer li_rowcount

// Ocultar botones
cb_nuevo.Visible = FALSE
cb_modificar.Visible = FALSE
cb_eliminar.Visible = FALSE

// Asignar transacción
dw_2.SetTransObject(SQLCA)
dw_3.SetTransObject(SQLCA)

// Obtener parámetros
IF IsValid(Message.PowerObjectParm) THEN
	lstr_param = Message.PowerObjectParm

	ls_periodo = lstr_param.s[1]
	ls_tipoplanilla = lstr_param.s[2]
	ls_tipoproceso = lstr_param.s[3]
	ll_empleado = Long(lstr_param.s[4])
ELSE
	MessageBox("Error", "No se recibieron los parámetros necesarios", StopSign!)
	Close(This)
	RETURN
END IF

// Validar parámetros
IF IsNull(ls_periodo) OR Trim(ls_periodo) = "" OR &
   IsNull(ls_tipoplanilla) OR Trim(ls_tipoplanilla) = "" OR &
   IsNull(ls_tipoproceso) OR Trim(ls_tipoproceso) = "" OR &
   IsNull(ll_empleado) OR ll_empleado <= 0 THEN
	MessageBox("Error", "Parámetros incompletos o inválidos", StopSign!)
	Close(This)
	RETURN
END IF

// Verificar si existe registro
lds_verificar = CREATE DataStore
lds_verificar.DataObject = "d_verificar_rebaja_existente"
lds_verificar.SetTransObject(SQLCA)

li_rowcount = lds_verificar.Retrieve(ls_periodo, ls_tipoplanilla, ls_tipoproceso, ll_empleado)

IF li_rowcount > 0 THEN
	// Modo EDITAR
	ll_idrebajadevolucion = lds_verificar.GetItemNumber(1, "idrebajadevolucion")
	DESTROY lds_verificar

	This.Tag = "EDITAR"

	li_resultado = wf_cargar_existente(ll_idrebajadevolucion)

	IF li_resultado <> 1 THEN
		Close(This)
		RETURN
	END IF

ELSE
	// Modo NUEVO
	DESTROY lds_verificar

	This.Tag = "NUEVO"

	li_resultado = wf_crear_nuevo(ls_periodo, ls_tipoplanilla, ls_tipoproceso, ll_empleado)

	IF li_resultado <> 1 THEN
		Close(This)
		RETURN
	END IF
END IF

sle_position.Text = ""

end event

event objectstartevent;
call super::objectstartevent

Choose Case eventname

	  CASE "opened"

    Case "cb_cerrar_periodo_clicked"
        wf_cerrar_periodo()

    Case "ue_close"
        Close(This)

End Choose

end event

type dw_3 from w_master_list`dw_3 within w_pr_rebaja_devolucion_add
boolean visible = true
integer x = 37
integer y = 596
integer width = 3415
integer height = 1096
string dataobject = "dw_pr_rebaja_devolucion_det"
end type

event dw_3::itemchanged;/*==================================================================
Evento: itemchanged de dw_3 (detalle)
Propósito: Calcular MontoAjuste automáticamente cuando cambie MontoFinal
==================================================================*/

decimal{2} ldc_montooriginal, ldc_montofinal, ldc_montoajuste
string ls_colname

ls_colname = dwo.name

IF ls_colname = "montofinal" THEN
	ldc_montooriginal = This.GetItemDecimal(row, "montooriginal")
	ldc_montofinal = Dec(data)

	IF NOT IsNull(ldc_montooriginal) AND NOT IsNull(ldc_montofinal) THEN
		ldc_montoajuste = ldc_montofinal - ldc_montooriginal
	ELSE
		ldc_montoajuste = 0
	END IF

	This.SetItem(row, "montoajuste", ldc_montoajuste)
END IF

end event

type dw_report from w_master_list`dw_report within w_pr_rebaja_devolucion_add
end type

type dw_2 from w_master_list`dw_2 within w_pr_rebaja_devolucion_add
integer x = 14
integer y = 4
integer width = 3735
integer height = 484
string dataobject = "dw_pr_rebaja_devolucion_cab"
boolean vscrollbar = false
boolean border = false
borderstyle borderstyle = stylebox!
end type

type st_1 from w_master_list`st_1 within w_pr_rebaja_devolucion_add
boolean visible = false
end type

type sle_position from w_master_list`sle_position within w_pr_rebaja_devolucion_add
boolean visible = false
end type

event sle_position::losefocus;
call super::losefocus

IF Len(Trim(This.Text)) > 0 THEN
    Parent.wf_position()
END IF

end event

event sle_position::modified;
IF Len(Trim(This.Text)) = 0 THEN
    dw_2.SelectRow(0, FALSE)
END IF

end event

type cb_hide from w_master_list`cb_hide within w_pr_rebaja_devolucion_add
end type

type cb_nuevo from w_master_list`cb_nuevo within w_pr_rebaja_devolucion_add
boolean visible = false
integer height = 84
end type

type cb_modificar from w_master_list`cb_modificar within w_pr_rebaja_devolucion_add
boolean visible = false
integer height = 84
end type

type cb_eliminar from w_master_list`cb_eliminar within w_pr_rebaja_devolucion_add
boolean visible = false
integer height = 84
end type

